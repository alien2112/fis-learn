/**
 * Video Provider Interface
 *
 * Provider-agnostic interface for video hosting and streaming.
 * Implement this interface for any video provider (Mux, Cloudflare Stream, AWS IVS, Vimeo, etc.)
 *
 * To add a new provider:
 * 1. Create a new file: mux.provider.ts, cloudflare-stream.provider.ts, etc.
 * 2. Implement the VideoProvider interface
 * 3. Register it in the VideoModule with the VIDEO_PROVIDER token
 * 4. Update .env with the provider's credentials
 *
 * To switch providers:
 * 1. Change VIDEO_PROVIDER in .env
 * 2. The application will automatically use the new provider
 */

// ============ UPLOAD & ASSET MANAGEMENT ============

export interface VideoUploadOptions {
  /** Title for the video asset */
  title: string;
  /** Optional description */
  description?: string;
  /** Folder/collection to organize the video */
  folderId?: string;
  /** Enable DRM protection (if provider supports) */
  enableDrm?: boolean;
  /** Enable per-viewer watermarking (if provider supports) */
  enableWatermark?: boolean;
  /** Custom metadata to store with the video */
  metadata?: Record<string, string>;
  /** Allowed playback domains (security) */
  allowedDomains?: string[];
  /** Max resolution to encode (e.g., '1080p', '4k') */
  maxResolution?: '720p' | '1080p' | '1440p' | '4k';
  /** Generate subtitle tracks automatically */
  autoGenerateCaptions?: boolean;
  /** Languages for auto-generated captions */
  captionLanguages?: string[];
}

export interface DirectUploadUrl {
  /** URL to upload the video file to */
  uploadUrl: string;
  /** Asset ID that will be created */
  assetId: string;
  /** Provider-specific upload instructions */
  instructions?: {
    method: 'PUT' | 'POST';
    headers?: Record<string, string>;
    maxSizeBytes?: number;
    expiresAt?: Date;
  };
}

export interface VideoAsset {
  /** Unique identifier in our system */
  id: string;
  /** Provider's asset ID */
  providerAssetId: string;
  /** Provider name */
  provider: string;
  /** Processing status */
  status: VideoAssetStatus;
  /** Video title */
  title: string;
  /** Duration in seconds (available after processing) */
  duration?: number;
  /** Aspect ratio (e.g., '16:9') */
  aspectRatio?: string;
  /** Available resolutions after encoding */
  resolutions?: string[];
  /** Thumbnail URLs at different sizes */
  thumbnails?: {
    small?: string;
    medium?: string;
    large?: string;
    animated?: string; // GIF/WebP preview
  };
  /** Timeline thumbnail sprite for scrubbing */
  thumbnailVttUrl?: string;
  /** Available subtitle/caption tracks */
  subtitles?: SubtitleTrack[];
  /** File size in bytes */
  sizeBytes?: number;
  /** DRM protection enabled */
  drmEnabled?: boolean;
  /** Created timestamp */
  createdAt: Date;
  /** Last updated timestamp */
  updatedAt: Date;
  /** Provider-specific metadata */
  providerMetadata?: Record<string, any>;
}

export type VideoAssetStatus =
  | 'preparing' // Upload URL generated, waiting for upload
  | 'uploading' // Upload in progress
  | 'processing' // Transcoding/encoding
  | 'ready' // Ready for playback
  | 'errored' // Processing failed
  | 'deleted'; // Soft deleted

export interface SubtitleTrack {
  /** Language code (e.g., 'en', 'es', 'ar') */
  language: string;
  /** Display label (e.g., 'English', 'Spanish') */
  label: string;
  /** URL to the subtitle file */
  url: string;
  /** Format (vtt, srt) */
  format: 'vtt' | 'srt';
  /** Auto-generated or manually uploaded */
  autoGenerated: boolean;
}

// ============ PLAYBACK & SECURITY ============

export interface PlaybackContext {
  /** User ID for watermarking and tracking */
  userId: string;
  /** User email for visible watermark */
  userEmail: string;
  /** User's IP address */
  ipAddress: string;
  /** Device/browser fingerprint */
  deviceFingerprint?: string;
  /** Session ID for concurrent stream limiting */
  sessionId: string;
  /** Token expiration time in seconds */
  expiresIn: number;
  /** Geographic restrictions */
  allowedCountries?: string[];
  /** Referrer domain restrictions */
  allowedDomains?: string[];
}

export interface PlaybackToken {
  /** The signed token */
  token: string;
  /** Token expiration timestamp */
  expiresAt: Date;
  /** Provider-specific token data */
  providerData?: Record<string, any>;
}

export interface PlaybackUrls {
  /** HLS manifest URL (for most browsers) */
  hls?: string;
  /** DASH manifest URL (for DRM) */
  dash?: string;
  /** Direct MP4 URLs for progressive download (fallback) */
  mp4?: {
    quality: string;
    url: string;
    sizeBytes?: number;
  }[];
}

export interface DrmConfig {
  /** Widevine license URL (Chrome, Android, Chromium browsers) */
  widevine?: {
    licenseUrl: string;
    headers?: Record<string, string>;
  };
  /** FairPlay license URL (Safari, iOS, macOS) */
  fairplay?: {
    licenseUrl: string;
    certificateUrl: string;
    headers?: Record<string, string>;
  };
  /** PlayReady license URL (Edge, Windows apps) */
  playready?: {
    licenseUrl: string;
    headers?: Record<string, string>;
  };
}

export interface WatermarkConfig {
  /** Enable visible watermark */
  visible: boolean;
  /** Text to display (e.g., user email) */
  text: string;
  /** Opacity (0-1) */
  opacity: number;
  /** Position strategy */
  position: 'fixed' | 'random' | 'moving';
  /** Font size in pixels */
  fontSize?: number;
  /** Text color */
  color?: string;
  /** Reposition interval in seconds (for 'random' position) */
  repositionInterval?: number;
}

export interface PlaybackManifest {
  /** Playback URLs for different streaming protocols */
  urls: PlaybackUrls;
  /** DRM configuration (if enabled) */
  drm?: DrmConfig;
  /** Watermark configuration */
  watermark?: WatermarkConfig;
  /** Subtitle tracks */
  subtitles: SubtitleTrack[];
  /** Thumbnail VTT for timeline scrubbing */
  thumbnailVttUrl?: string;
  /** Poster/thumbnail image */
  posterUrl?: string;
  /** Video duration in seconds */
  duration?: number;
  /** Token expiration */
  expiresAt: Date;
}

// ============ ANALYTICS ============

export interface VideoAnalytics {
  /** Total views */
  views: number;
  /** Unique viewers */
  uniqueViewers: number;
  /** Total watch time in seconds */
  totalWatchTime: number;
  /** Average watch percentage */
  averageWatchPercentage: number;
  /** Peak concurrent viewers */
  peakConcurrentViewers?: number;
  /** View-through rate (completed / started) */
  completionRate: number;
  /** Engagement heatmap (percentage watched per segment) */
  engagementData?: {
    /** Segment start time in seconds */
    startTime: number;
    /** Segment end time in seconds */
    endTime: number;
    /** Percentage of viewers who watched this segment */
    watchedPercentage: number;
  }[];
  /** Views by country */
  viewsByCountry?: Record<string, number>;
  /** Views by device type */
  viewsByDevice?: {
    desktop: number;
    mobile: number;
    tablet: number;
    tv: number;
  };
}

export interface DateRange {
  start: Date;
  end: Date;
}

// ============ WEBHOOK EVENTS ============

export interface VideoWebhookEvent {
  /** Event type */
  type: VideoWebhookEventType;
  /** Provider name */
  provider: string;
  /** Asset ID (if applicable) */
  assetId?: string;
  /** Event timestamp */
  timestamp: Date;
  /** Event-specific data */
  data: Record<string, any>;
  /** Raw payload for verification */
  rawPayload: string | Buffer;
  /** Signature for verification */
  signature?: string;
}

export type VideoWebhookEventType =
  | 'video.asset.created'
  | 'video.asset.ready'
  | 'video.asset.errored'
  | 'video.asset.deleted'
  | 'video.upload.started'
  | 'video.upload.completed'
  | 'video.subtitles.ready'
  | 'video.live.started'
  | 'video.live.ended'
  | 'video.live.recording.ready';

// ============ MAIN INTERFACE ============

/**
 * Video Provider Interface
 *
 * All video providers must implement this interface.
 * The implementation handles provider-specific logic internally.
 */
export interface VideoProvider {
  /**
   * Provider identifier (e.g., 'mux', 'cloudflare', 'aws-ivs')
   */
  readonly providerName: string;

  /**
   * Whether this provider supports DRM
   */
  readonly supportsDrm: boolean;

  /**
   * Whether this provider supports adaptive streaming (HLS/DASH)
   */
  readonly supportsAdaptiveStreaming: boolean;

  /**
   * Whether this provider supports live streaming
   */
  readonly supportsLiveStreaming: boolean;

  // ============ UPLOAD METHODS ============

  /**
   * Create a direct upload URL for client-side uploads
   * The client uploads directly to the provider, avoiding server bandwidth
   */
  createDirectUpload(options: VideoUploadOptions): Promise<DirectUploadUrl>;

  /**
   * Upload a video from a URL (server-side)
   * Provider fetches the video from the URL
   */
  uploadFromUrl(url: string, options: VideoUploadOptions): Promise<VideoAsset>;

  // ============ ASSET MANAGEMENT ============

  /**
   * Get a video asset by ID
   */
  getAsset(assetId: string): Promise<VideoAsset | null>;

  /**
   * List video assets with pagination
   */
  listAssets(options?: {
    limit?: number;
    cursor?: string;
    status?: VideoAssetStatus;
  }): Promise<{
    assets: VideoAsset[];
    nextCursor?: string;
    hasMore: boolean;
  }>;

  /**
   * Update video asset metadata
   */
  updateAsset(
    assetId: string,
    updates: Partial<Pick<VideoUploadOptions, 'title' | 'description' | 'metadata'>>,
  ): Promise<VideoAsset>;

  /**
   * Delete a video asset
   */
  deleteAsset(assetId: string): Promise<void>;

  // ============ PLAYBACK ============

  /**
   * Generate a signed playback token for secure video access
   */
  generatePlaybackToken(assetId: string, context: PlaybackContext): Promise<PlaybackToken>;

  /**
   * Get playback URLs and configuration for a video
   */
  getPlaybackManifest(assetId: string, token: PlaybackToken): Promise<PlaybackManifest>;

  // ============ SUBTITLES ============

  /**
   * Add a subtitle track to a video
   */
  addSubtitle(
    assetId: string,
    subtitle: {
      language: string;
      label: string;
      file: Buffer | string; // Buffer or URL
      format?: 'vtt' | 'srt';
    },
  ): Promise<SubtitleTrack>;

  /**
   * Remove a subtitle track
   */
  removeSubtitle(assetId: string, language: string): Promise<void>;

  // ============ ANALYTICS ============

  /**
   * Get analytics for a video asset
   */
  getAnalytics(assetId: string, dateRange: DateRange): Promise<VideoAnalytics>;

  // ============ WEBHOOKS ============

  /**
   * Verify and parse a webhook event from the provider
   */
  verifyWebhook(payload: string | Buffer, signature: string, secret: string): VideoWebhookEvent;
}

/**
 * Injection token for the video provider
 */
export const VIDEO_PROVIDER = Symbol('VIDEO_PROVIDER');

/**
 * Configuration for video provider selection
 */
export interface VideoProviderConfig {
  /** Active provider name */
  provider: 'mux' | 'cloudflare' | 'aws-ivs' | 'vimeo' | 'bunny';
  /** Provider-specific configuration */
  config: Record<string, any>;
}
